\documentclass[12pt,a4paper]{scrreprt}
\usepackage{amsmath,amssymb,mathrsfs,dsfont}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage{listings}
\lstset{frame=tb,
language=C,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numbers=none,
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3
}
\oddsidemargin0mm \evensidemargin3mm \textwidth150mm \textheight23cm
\parindent0mm \pagestyle{empty} \topmargin-1cm
\pagestyle{headings}
%euro-zeichen f. utf8
\usepackage{eurosym}
\DeclareUnicodeCharacter{20AC}{\euro}

\begin{document}

\begin{enumerate}

\item %1.
Die Zahlen $+0 , -0 , +\infty , -\infty,$ not a number$, 64.625, 75.4, -2$ sind als 32-Bit Gleitpunktzahlen zu schreiben.

\begin{enumerate}
    \item $+0$
    \item $-0$
    \item $+\infty 1.0·2^128$
    \item $-\infty $
	\item NAN
    \item $64.625$
    \item $75.4$
    \item $-2$
\end{enumerate}

\item %2.
Die folgenden 32-Bit Gleitpunktzahlen sind dual, hexadzimal und angenähert dezimal anzugeben:

\begin{itemize}
\item die größte Gleitpunktzahl
\item die kleinste Gleitpunktzahl
\item die kleinste positive Gleitpunktzahl größer als Null
\item die größte negative Gleitpunktzahl
\end{itemize}

\item %3.
Die folgenden 64-Bit Gleitpunktzahlen sind dual, hexadzimal und angenähert dezimal anzugeben:

\begin{itemize}
\item die größte Gleitpunktzahl
\item die kleinste Gleitpunktzahl
\item die kleinste positive Gleitpunktzahl größer als Null
\item die größte negative Gleitpunktzahl
\end{itemize}

\item\label{umwandlungsalgo} %4.
Die Umwandlung einer ganzen positiven Dezimalzahl in eine Zahl mit Basis b ($2 < = b <= 36$) soll als Algorithmus in Form eines Programmablaufplanes formuliert werden. Im Algorithmus sollen die Dezimalzahl d und die Basis b eingelesen und auf $d>=0$ und $2<=b<=36$
getestet werden. Die Speicherung der Ziffern der umgewandelten Zahl soll in einem Vektor in Form von ASCII-Zeichen erfolgen. Der Vektor soll ausgegeben werden.

\item\label{umwandlungsprogramm} %5.
Der Algorithmus der \ref{umwandlungsalgo}. Aufgabe ist als C-Programm zu implementieren. Die Umrechnung von d in eine Zahl zur Basis b soll über eine Funktion mit 3 Parametern (unsigned long d, unsigned long b, char *z) und dem Funktionstyp int erfolgen. Im Falle einer unzulässigen Basis $(b<2 oder b>36)$ wird eine 1 zurückgegeben, sonst 0. Das Ergebnis der Umwandlung wird als Folge von ASCII-Zeichen in z eingetragen. Eine Funktion
reverse(char *) kehrt den Inhalt von z (vor der Ausgabe) um.

\item\label{algo2} %6.
Die Umwandlung einer gebrochenen positiven Dezimalzahl der Form
$0.f..f$ in eine Zahl mit Basis $b (2 <= b <= 36)$ soll als Algorithmus
formuliert werden. Im Algorithmus sollen der Bruch d, die Basisb und
die Anzahl der Nachkommastellen im Zielsystem eingelesen und auf
$d >= 0$ und $2 <= b <= 36$ getestet werden. Die Speicherung der Ziffern
der umgewandelten Zahl soll in einem Vektor in Form von ASCII-Zeichen
erfolgen. Der Vektor soll ausgegeben werden.

\item %7.
Der Algorithmus der \ref{algo2}. Aufgabe so ll analog zur \ref{umwandlungsprogramm}.Aufgabe als C-Pro-
gramm implementiert werden. Beispiel für den Dialog:
Umwandlung eines Dezimalbruchs in beliebiges System
===================================================
Umzuwandelnder Dezimalbruch aus [0,1] ? 0.125
B as is d es Z ie ls y ste m s a u s [ 2 , 36 ] ? 1 6
Anzahl der Nachkommastellen im Zielsystem ? 10
(0.125)10 = (0.2)16
0.125 * 16 =
2 Ueberlauf 2
0 * 16 =
0 Ue berl auf 0

\end{enumerate}

\end{document}
