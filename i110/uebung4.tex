\documentclass[12pt,a4paper]{scrreprt}
\usepackage{amsmath,amssymb,mathrsfs,dsfont}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref}
\usepackage{color}
\usepackage{comment}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage{listings}
\lstset{frame=tb,
language=C,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numbers=none,
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3
}
\oddsidemargin0mm \evensidemargin3mm \textwidth150mm \textheight23cm
\parindent0mm \pagestyle{empty} \topmargin-1cm
\pagestyle{headings}
%euro-zeichen f. utf8
\usepackage{eurosym}
\DeclareUnicodeCharacter{20AC}{\euro}

\begin{document}

\begin{enumerate}
\item Aufgabe %1:
Ein Algorithmus in Form eines Flussdiagrammes (PAP) oder Struktogrammes (Nassi-Shneidermann-Diagramm) soll die Umrechnung von Fahrenheit-Werten in Celsius-Werte ermöglichen. Die Variablen lower, upper und step sollen eingelesen werden. Diese Variablen beschreiben in der genannten Reihenfolge die untere und obere Fahrenheit-Temperatur und step die Schrittweite ( 0 < step gefordert). Die Umrechnungsformel lautet: celsius=5.0*(fahrenheit-32.0)/9.0 .
Von lower bis upper sollen mit der Schrittweite step zu jedem Fahrenheit-Wert der zugehörige Celsius-Wert berechnet und ausgegeben werden. Der Algorithmus kann optional als C-Programm implementiert werden.

\begin{comment}
    (1)_Start
    (2)_Input:lower 
    (1)->(2)
    (3)_Input:upper
    (2)->(3)
    (4)_Input:step 
    (3)->(4)
    (6)_Output:(lower-32.0)/1.8  //ungekürzt: 5.0*(fahrenheit-32.0)/9.0
    (4)->(5)
    (5)_If(0 < step)?(5)->(6)
    (5)->(4)
    (7)_Set:lower+=step
    (6)->(7)
    (9)_End
    (8)_If(lower < upper)?(8)->(6)
    (8)->(9)
\end{comment}

\item Aufgabe %2

Gegeben sind die drei Koeffizienten $ a, b, c$, wobei diese beliebige reele Werte haben können. Gesucht sind alle reellen und komplexen Werte von $ x $, für welche die Gleichung $ a * x^2 + b * x + c = 0 $ erfüllt ist. Im Falle von $ \sqrt{-1} $ setzen Sie den Buchstaben $ i $ ein.
Der Algorithmus kann optional als C-Programm implementiert werden.

\begin{lstlisting}
    double gleichung(double a, double b, double c){
      double x;
      /*
        a * x^2 + b * x + c = 0
      */
      return x;
    }
\end{lstlisting}

\item Aufgabe %3

Gegeben seien 2 Zeitspannen der Form tag; h; min; sec; msec . Formulieren Sie ein Flußdiagramm, welches die Summe der beiden Zeitspannen berechnet und von der Summe die tag-, h-, min-, sec- und msec-Werte ausgibt. Für jeden Summanden sind die tag-, h-, min-, sec- und msec-Werte am Anfang einzulesen. Für die Werte sind folgende Intervalle einzuhalten: $ 0<=tag$, $ 0 <= h<24$, $ 0<= min < 60 $, $ 0<= sec < 60$, $ 0<= msec < 1000$. Bei der Eingabe wird solange eine Schleife für jeden Wert durchlaufen, bis der gelesene Wert im angegebenen Intervall liegt. Der Algorithmus kann optional als C-Programm implementiert werden.

\begin{comment}
    \begin{flussdiagramm}
      \begin{while}{!(0<=tag1)}
        \input{tag1}
      \end{while}
      \begin{while}{!(0<=h1)}
        \input{h1}
      \end{while}
      \begin{while}{!(0<=min1<60)}
        \input{min1}
      \end{while}
      \begin{while}{!(0<=sec1<60)}
        \input{sec1}
      \end{while}
      \begin{while}{!(0<=msec1<1000)}
        \input{msec1}
      \end{while}
      \begin{while}{!(0<=tag2)}
        \input{tag2}
      \end{while}
      \begin{while}{!(0<=h2)}
        \input{h2}
      \end{while}
      \begin{while}{!(0<=min2<60)}
        \input{min2}
      \end{while}
      \begin{while}{!(0<=sec2<60)}
        \input{sec2}
      \end{while}
      \begin{while}{!(0<=msec2<1000)}
        \input{msec2}
      \end{while}
      \command{t=tag1+tag2}
      \command{h=h1+h2}
      \command{m=min1+min2}
      \command{s=sec1+sec2}
      \command{n=msec1+msec2}
      \command{sum=n+s*1000+m*60000+h*3600000+t*24*3600000}
      \command{t=sum/(24*3600000)}
      \command{sum=sum mod (24*3600000)}
      \command{h=sum/(3600000)}
      \command{sum=sum mod (3600000)}
      \command{m=sum/(60000)}
      \command{sum=sum mod (60000)}
      \command{n=sum/(1000)}
      \output{Tage: t, Stunden: h, Minuten: m, Sekunden: m, Millisekunden: n}
    \end{flussdiagramm}
\end{comment}

\item Aufgabe %4

In unserem Kalender sind zum Ausgleich der astronomischen und kalendarischen Jahreslänge in regelmäßigen Abständen Schaltjahre eingebaut. Zur exakten Festlegung der Schaltjahre dienen die folgenden Regeln:

1. Ist die Jahreszahl durch 4 teilbar, so ist das Jahr ein Schaltjahr. Diese Regel hat allerdings eine Ausnahme:
2. Ist die Jahreszahl durch 100 teilbar, so ist das Jahr kein Schaltjahr. Diese Ausnahme hat wiederum eine Ausnahme:
3. Ist die Jahreszahl durch 400 teilbar, so ist das Jahr doch ein Schaltjahr.

Erstellen Sie ein Flußdiagramm, das berechnet, ob eine vom Benutzer eingegebene Jahreszahl ein Schaltjahr ist oder nicht. Der Algorithmus kann optional als C-Programm implementiert werden.

    int schaltjahr(int jahr){
      return !(jahr%4) && ((jahr%100) || !(jahr%400));
    }

\item Aufgabe %5

Es ist der Funktionswert $ y = a $ für $ a = 4 $ mit dem sumerisch-babylonischen Wurzelziehen (Heron-Verfahren) manuell iterativ für 4 Iterationsschritte $ (x_1, y_1) $ bis $ (x_4, y_4) $ zu berechnen, wobei mit dem Iterationsverfahren $ x_1 := (x_0 + y_0) / 2 , y_1 := a / x_1 $ bzw. $ x_n+1 := (x_n + y_n) / 2 , y_n+1 := a / x_n+1 $ gearbeitet werden soll. Für jedes $ i, 1 <= i <= 4 $ ist $ x_i * y_i $ auszurechnen und zu notieren.
Alternativ ist $ x_4 $ mittels der folgenden Formel auszurechnen und zu notieren:
$ x0 := a / 2 und xi := ( xi-1 + a / xi-1 ) / 2 , i = 1, 2, 3, ... $

\item Aufgabe %6

Der größte gemeinsame Teiler ist mittels des Euklidischen Algorithmus sowohl über ggT(54, 81) manuell rekursiv als auch über Euklid(54, 81) manuell iterativ zu bestimmen:

\begin{lstlisting}
   long ggT(long n, long m){                   // Rekursiver Algorithmus von Euklid
      if(abs(m)>abs(n)) return abs(ggT(m,n));   // vertauschen von n und m
      if(!m) return abs(n);                     // if(m == 0) return abs(n), Abbruch
      return abs(ggT(m,n%m));                   // rekursiver Schritt
    }

    long Euklid(long a, long b){
      a = abs(a); b=abs(b);
      while(a*b){
        if(a >= b) a = a % b;
        else b = b % a;
      }
      return a + b;
    }     // Iterativer Algorithmus von Euklid
\end{lstlisting}

\item Aufgabe %7

Die Fakultät einer natürlichen Zahl ist wie folgt definiert: $ 0! = 1 , 1! = 1, n! = (n-1)! * n \text{, für} n >= 1$. Formulieren Sie \textbf{sowohl ein Struktogramm für die rekursive als auch für die iterative Berechnung}. Die Algorithmen können \textbf{optional als C-Programm} implementiert werden (rekursiv und iterativ).

%howto struktogramm
%http://ctan.sharelatex.com/tex-archive/macros/latex/contrib/struktex/struktex.en.pdf
\begin{comment}
- (in)E: n
- (cond)? n>=0
- (f:back:in)
- (cond)? n=>2
- (f:out) A: 1
- (fin) f=1
- i=2
- f=f*i
\end{comment}

\begin{lstlisting}
unisgned long long fak_iterativ(n){
	unsigned long long f=1ULL;
	unsigned int i;
	if(n > 20U){
		return 0;	//keine Loesung
	}
	for(i=0U ; i <= n ; i++){
		f*=i;
	}
	return f;
}

unisgned long long fak_rekursiv(int n){
	if(n > 20U || n < 0){
		return 0ULL;	//keine Loesung fuer negative Zahlen oder zu grosse Zahlen
	}else if(n < 2){
		return 1ULL;
	}
	return fak_rekursiv(n-1)*n;
}
\end{lstlisting}

\item Aufgabe %8

Fibonacci - Zahlen F(n) werden für natürliche Zahlen $n>=2$ \textbf{rekursiv} über die For-
mel $F(n) := F(n-1) + F(n-2)$ berechnet, wobei die Anfangswerte $F(0)=0$ für $n=0$, $F(1)=1$ für
$n=1$ gelten. Alternativ analytisch erfolgt die Berechnung von $F(n)$ über die folgende Formel:

$F(n)=\frac{1}{\sqrt{5}} (\frac{1+\sqrt{5}}{2})=^{n} - (\frac{1-\sqrt{5}}{2})^{n})$

Formulieren Sie ein Struktogramm für die \textbf{rekursive}, die \textbf{analytische} und die \textbf{iterative} Berechnung der Fibonacci-Zahlen. Die Algorithmen können optional als C-Programme implementiert werden (jeweils rekursiv, analytisch und iterativ).

\begin{comment}
algo rekursiv:
F(4) = F(3) + F(2)
     = F(2)+F(1) + F(1)+F(0)
     = 1+1 + 1+0

%struktogramm
fibr:
(n>=0)f: A:Fehler
(n>0)f: A:0
(n>1)f: A:1
fibr(n-1)+fibr(n-2)

\begin{lstlisting}
unsigned long long(unsigned char n){
	if(n==0U)return 0ULL;
	if(n==1U)return 1ULL;
	return fibr(n-1U)+fibr(n-2U);
}
\end{lstlisting}

algo iterativ:
fibi:
(n>=0)f: Fehler
vorgaenger=1
vorvorgaenger=0
zaehler=1
(inc)zaehler++
(i<=n)f: A:zahl
zahl=vorgaenger+vorvorgaenger
back:inc

%struktogramm
fibi:

\begin{lstlisting}
unsigned long long fibi(unsigned char n){
	unsigned long long *f;
	unsigned long long i,r;
	if(n<=14)return (unsigned long long)n;
	f=(unsigned long long*)malloc((n+1)*sizeof(unsigned lon long));
	f[0]=0ULL;//zwei elm reichen statt 
	f[1]=1ULL;
	for(i=2U ; i<=n ; i++){
		f[i]=f[i-1]+f[i-1];
	}
	r=f[n];
	free(f);
	return f[i-1];
}
\end{lstlisting}

\end{comment}

\item Aufgabe %9

Die Ackermannsche Funktion ist ein Beispiel für eine totale und berechenbare
Funktion, die nicht primitiv-rekursiv ist. Diese Funktion ist mehrfach rekursiv:
Ackermann(m, n) := wenn m == 0, dann n + 1;
wenn n == 0, dann Ackermann( m - 1, 1)
sonst Ackermann(m-1, Ackermann(m, n-1))

a.) Rechnen Sie Ackermann(2, 3) manuell aus.
b.) Formulieren Sie ein Struktogramm zur Berechnung der Ackermannschen Funktion.
Der rekursive Algorithmus kann optional als C-Programm implementiert werden.

\item Aufgabe %10:

Binomialkoeffizienten $\binom{n}{k}$ beschreiben die Anzahl der Möglichkeiten, $k$ Elemente aus einer Grundgesamtheit $n$ auszuwählen, wobei immer $0 <= k <= n$ gelten muss und $n$ und $k$ natürliche Zahlen sind. Ein numerisch stabiles Verfahren, um Binomialkoeffizienten zu berechnen, ergibt sich aus folgender Formel:
$\binom{n}{k} = \binom{n-1}{k-1}+\binom{n-1}{k}$ \\
Es gilt $\binom{n}{0}=1$, $\binom{n}{1}=n$ und $\binom{n}{k}=\frac{n!}{(n-1)! \cdot k!}$

Der Algorithmus ist \textbf{rekursiv} und \textbf{iterativ} zu entwerfen. Beide Algorithmen können optional als C-Programme implementiert werden.

\begin{comment}
n ueber k mit einer matrix

iterativ
\begin{tabular}
0 & k	\\
n & 1 & 0 & 0 & 0	\\
  & ... & 1 & 1 & 0	\\
  & 1 & 2
\end{tabular}

\end{comment}

\item Aufgabe %11

Eine weitere mehrfach rekursive Funktion, ähnlich der Ackermann-Funktion, ist die wie folgt definierte Hofstadter-Funktion:
hof(n) := 1, wenn n<= 2
hof(n) := hof(n - hof(n-1)) + hof(n - hof(n-2)), wenn n>2

a.) Rechnen Sie hof(5) manuell aus.
b.) Formulieren Sie je einen Programmablaufplan für die rekursive und für die iterative Berechnung, implementieren Sie optional je ein C-Programm für die rekursive und die iterative Berechnung.

\end{enumerate}

\end{document}
