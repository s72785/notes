\documentclass[12pt,a4paper]{scrreprt}
\usepackage{amsmath,amssymb,mathrsfs,dsfont}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{hyperref}

\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\usepackage{listings}
\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\oddsidemargin0mm \evensidemargin3mm \textwidth150mm \textheight23cm
\parindent0mm \pagestyle{empty} \topmargin-1cm
\pagestyle{headings}

%euro-zeichen f. utf8
\usepackage{eurosym}
\DeclareUnicodeCharacter{20AC}{\euro}

\begin{document}

\begin{enumerate}

\item Aufgabe %1:

Die Funktion $ e^x $ ist wie folgt über eine unendliche Reihe definiert:

\[
e^x = 1 + \frac{x^1}{1!} + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + ...
= \Sigma_{n=0}^{\infty} \frac{x^n}{n!}
\]

Formulieren Sie einen Algorithmus in Form eines Flußdiagrammes, der die Berechnung der Summe abbricht, wenn zwei aufeinanderfolgende Summen eine Differenz kleiner als $\epsilon$ haben.
Die Varaible $x$ und $\epsilon$ (z.B. $10^{-8}$ ) sind einzulesen. Der genäherte Wert für $ e^x $ und das erreichte $ n $ sind auszugeben.

\begin{lstlisting}
    #include<math.h>
    void ehochx(double x, double epsilon, double* sum1, int* n){
      double sum2=1.0;
      *sum1=0.0;
      *n=0;
      while( (sum2 - *sum1) > epsilon  ){
        *sum1 = sum2;
        sum2 += pow(x, *n);
        *n++;
      }
    }
\end{lstlisting}

\item Aufgabe %2:

Die folgenden Summen sind solange zu berechnen, bis der Absolutbetrag des Quotienten eines Summanden und der bisherigen Summe kleiner einer vorher eingelesenen positiven Schranke Epsilon ist. Die Algorithmen sollen als Struktogramme bzw. Flußdiagramme bzw. Programmablaufpläne formuliert werden, optional können C-Programme formuliert werden.

\begin{enumerate}

\item Berechnung von $\pi$ nach Leibniz: $ \Sigma_{n=0}^{\infty} \frac{(-1)^n}{2n+1} = 1-\frac{1}{3}+\frac{1}{5}-\frac{1}{7}+\frac{1}{9}-\ldots=\frac{\pi}{4} $

\begin{lstlisting}
    #include<math.h>
    void leibnitzpi(double epsilon, double* sum1, int* n){
      double sum2=1.0;
      *sum1=1.0;
      *n=1;
      while( (sum2 / *sum1) >= epsilon ){
        *sum1 = sum2;
        sum2 += pow(-1,*n)/(*n*2 + 1);
        *n+=2;
      }
    }
\end{lstlisting}

\item Berechnung von $\pi$ nach Bailey-Borwein-Plouffe (1996): $ \pi = \Sigma_{k=0}^{\infty} \frac{1}{16^k} \left( \frac{4}{8k+1} \frac{2}{8k+4} \frac{1}{8k+5} \frac{1}{8k+6} \right)  $

\item Berechnung von ln(x):

\item Berechnung von cos(x):

\item Berechnung von arctan(x) für |x| <= 1:

\end{enumerate}

\item Aufgabe %3:

Auf Produkte x, y und z gibt es bei einem Händler folgende Rabatte:
Beim Kauf von Produkt x gilt:
Bis zum 9.Stck. gibt es keinen Rabatt, für das 10. - 19.Stück gibt es 10\% Rabatt pro Stück.
Für das 20. - 39.Stück gibt es 15\% Rabatt pro Stück.
Für das 40. - 49.Stück gibt es nur noch 5\% Rabatt pro Stück.
Für das 50.Stück und weitere Stücke des Produktes x gibt es keinen Rabatt mehr.
Beim Kauf von Produkt y gilt:
Ab 6. Stück gibt es 5,- € Rabatt pro Stück für alle Stücke von 1 an.
Ab 10. Stück gibt es 10,- € Rabatt pro Stück für alle Stücke von 1 an.
Der Gesamtrabatt für Produkt y ist auf maximal 140 € beschränkt.
Beim Kauf von Produkt z gilt:
Auf jedes Stück gibt es 8\% Rabatt, ab 25. Stück gibt es keinen Rabatt mehr.
Für die drei Produkte x, y und z gemeinsam ist die Gesamtrabattsumme auf 500,- €
beschränkt, d.h. beim Überschreiten von 500,- € Gesamtrabattsumme für einen Warenkorb
aus x,y und z gibt es keinen Rabatt mehr !
Es ist ein Flußdiagramm zu formulieren, welches die Anzahl der gekauften Produkte von
x, y und z und die Preise/Produkt von x, y und z jeweils getrennt einliest und aufgrund der
genannten Vorgaben algorithmisch den Gesamtpreis sowohl ohne als auch mit Rabatt ermittelt
und ausgibt. Der Geldbetrag des erzielten Rabatts ist ebenfalls auszugeben. Beim Einlesen soll si-
chergestellt werden, daß Anzahl 0 und Preis  0,- € ist.
Optional kann der Algorithmus als ein C-Programm geschrieben werden.

\item Aufgabe %4:

(a) Führen Sie das Siebverfahren des Eratosthenes manuell auf Papier für die natürlichen Zahlen von 1 bis 60 durch.

\begin{lstlisting}
 -1-   2   3   -4-   5   -6-   7   -8-   -9-  -10-
11  -12-  13  -14-  -15-  -16-  17  -18-  19  -20-
-21-  -22-  23  -24-  -25-  -26-  -27-  -28-  29  -30-
31  -32-  -33-  -34-  -35-  -36-  37  -38-  -39-  -40-
41  -42-  43  -44-  -45-  -46-  47  -48-  -49-  -50-
-51-  -52-  53  -54-  -55-  -56-  -57-  -58-  59  -60-
\end{lstlisting}

(b) Formulieren Sie einen Programmablaufplan bzw. ein Flußdiagramm bzw. ein Struktogramm, welches das Siebverfahren von Eratosthenes bis n (n > 0) realisiert.

    solange i<n
      j = wähle nöchste zahl aus ungestrichenen zahlen
      solange j<n
        streiche vielfache von j

(c) Führen Sie das optimierte Verfahren, \href{run:Algorithmen_Heron_Euklid_Prim.pdf}{Algorithmen}, S. 11, Vorlesung 4 manuell auf Papier für die natürlichen Zahlen von 1 bis 60 durch.

(d) Formulieren Sie einen Programmablaufplan bzw. ein Flußdiagramm bzw. ein Struktogramm, welches das optimierte Verfahren bis n (n > 0) realisiert.

(e) optional: Schreiben Sie ein C-Programm zum Sieb- und zum optimierten Verfahren

\item Aufgabe %5:

Man teste den rekursiven Algorithmus zur Bestimmung der Primfaktoren am
Beispiel PFR(330). Es ist ein Programmablaufplan bzw. ein Flußdiagramm bzw. ein Strukto-
gramm zu formulieren, welches das rekursive Verfahren beschreibt.

\item Aufgabe %6:

Man teste den iterativen Algorithmus zur Bestimmung der Primfaktoren am
Beispiel primefactorization(330). Es ist ein Programmablaufplan bzw. ein Flußdia-
gramm bzw. ein Struktogramm zu formulieren, welches das iterative Verfahren beschreibt.

\item Aufgabe %7:

Man formuliere Programmablaufpläne für eine einfach verkettete Liste mit

\begin{lstlisting}
struct el { int value; /* Daten */
struct el *next; /* Zeiger auf naechstes Element */
}
struct el *start = 0, *p = 0; /* start ist Startzeiger, p Hilfszeiger */ und gegebenem p mit
p = (struct el *)malloc(sizeof(struct el)); /* Speicherplatz p auf dem heap */
\end{lstlisting}

für

\begin{lstlisting}
Insertfirst(inout: start, in: p)
/* Einfuegen p nach start */
Insertlast(inout: start, in: p)
/* Einfuegen p nach start */
Removefirst(inout: start)
/* Loeschen erstes Element nach start */
Removelast(inout: start)
/* Loeschen letztes Element nach start */
int Anzahl(inout: start)
/* Rueckgabe Anzahl der Listenelement */
Show(in: start)
/* Anzeige aller value-Werte */
RemovePos(inout: start, in: pos) /* Element an der Stelle pos loeschen (pos = 0 ..) */
Removeall(inout: start)
/* Alle Elemente loeschen */
\end{lstlisting}

\item Aufgabe %8:

Gesucht ist ein Algorithmus in Form eines Flußdiagrammes, Programmablaufpla-
nes oder Struktogrammes zur Berechnung von
\[
sin(x)=\Sigma_{i=0}^{\infty} (-1)^i \cdot \frac{x^{2 \cdot i+1}}{(2 \cdot i + 1)!}
\]
mit ( $0 < x <= \pi/2$ ) . Die Berechnung ist abzubrechen, wenn der absolute Betrag des Quotienten
aus dem ersten vernachlässigten Reihenglied und der Partialsumme kleiner als der Wert einer
positiven Schranke epsilon ist. Formulieren Sie den Algorithmus optional als C-Programm.

\item Aufgabe %9:

Es ist je ein Flußdiagramm für folgende Aufgaben zu formulieren, wobei die Vek-
toren, Matrizen und deren Grenzen als Parameter gegeben sind, die Zulässigkeit der mathema-
tischen Operation (korrekte Indexe) ist jedoch zu überprüfen:
Skalarprodukt zweier Vektoren, Summe zweier Vektoren, Multiplikation Matrix mit Vektor,
Multiplikation Matrix mit Matrix, Transponieren einer quadratischen Matrix.

\end{enumerate}

\end{document}
